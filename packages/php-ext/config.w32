ARG_ENABLE("html_to_markdown", "Enable html_to_markdown support", "yes");

if (PHP_HTML_TO_MARKDOWN != "no") {
    var extname = "html_to_markdown";
    var EXT = extname.toUpperCase();
    var dllname = "php_" + extname + ".dll";
    var placeholder = "placeholder.c";

    if (force_all_shared()) {
        PHP_HTML_TO_MARKDOWN_SHARED = true;
    }
    if (!PHP_HTML_TO_MARKDOWN_SHARED) {
        PHP_HTML_TO_MARKDOWN_SHARED = true;
    }

    var moduleDir = FSO.GetFolder(".").Path;
    if (typeof(configure_module_dirname) != "undefined" && configure_module_dirname.length) {
        moduleDir = FSO.GetAbsolutePathName(configure_module_dirname);
    }

    var workspaceRoot = moduleDir + "\\workspace";
    if (!FSO.FolderExists(workspaceRoot)) {
        var twoUpCargo = moduleDir + "\\..\\..\\Cargo.toml";
        var oneUpCargo = moduleDir + "\\..\\Cargo.toml";
        if (FSO.FileExists(twoUpCargo)) {
            workspaceRoot = FSO.GetAbsolutePathName(moduleDir + "\\..\\..");
        } else if (FSO.FileExists(oneUpCargo)) {
            workspaceRoot = FSO.GetAbsolutePathName(moduleDir + "\\..");
        } else {
            workspaceRoot = moduleDir;
        }
    }
    workspaceRoot = FSO.GetAbsolutePathName(workspaceRoot);
    STDOUT.WriteLine("html_to_markdown workspace root: " + workspaceRoot);

    // Export workspace path as Makefile variable for fragment
    MFO.WriteLine("");
    MFO.WriteLine("# html_to_markdown Rust workspace");
    MFO.WriteLine("HTMLTOMARKDOWN_WORKSPACE_DIR = " + workspaceRoot);
    MFO.WriteLine("");

    EXTENSION(extname, placeholder, PHP_HTML_TO_MARKDOWN_SHARED, "/DZEND_ENABLE_STATIC_TSRMLS_CACHE=1");
    AC_DEFINE("HAVE_" + EXT, 1, "Have " + extname + " support");
    ADD_FLAG("CFLAGS_PHP", "/D COMPILE_DL_" + EXT);
    extensions_enabled[extensions_enabled.length] = [extname, 'shared', false];

    ADD_MAKEFILE_FRAGMENT("Makefile.frag.w32");
}
