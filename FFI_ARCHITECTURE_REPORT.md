# FFI Crate Architecture Report: html-to-markdown-ffi

## Executive Summary

The `html-to-markdown-ffi` crate provides a C-compatible FFI layer for the core HTML→Markdown conversion engine. This report documents the current architecture patterns, error handling mechanisms, string marshalling utilities, and integration points for building a visitor FFI bridge.

---

## 1. Current FFI Architecture

### 1.1 Module Organization

**File Structure:**
```
crates/html-to-markdown-ffi/
├── src/
│   ├── lib.rs              # Main FFI entry point (inline implementations)
│   ├── conversion.rs       # Basic conversion functions (C-String API)
│   ├── error.rs            # Thread-local error storage & reporting
│   ├── strings.rs          # String marshalling utilities
│   ├── metadata.rs         # Metadata extraction functions (feature-gated)
│   ├── profiling.rs        # Performance profiling (pprof integration)
│   └── tests.rs            # Inline test suite
├── cbindgen.toml           # C header generation config
├── build.rs                # Build-time header generation
└── Cargo.toml              # Dependencies & features
```

### 1.2 Crate Type & Distribution

**Library Configuration (Cargo.toml):**
```toml
[lib]
crate-type = ["cdylib", "staticlib"]  # Produces both .so/.dll and .a/.lib
```

**Key Dependencies:**
- `html-to-markdown-rs` (core library with features: `inline-images`, `metadata`)
- `serde_json` (metadata serialization)
- `pprof` (optional, Unix/Linux only, for flamegraph profiling)

**Version Management:**
- Uses workspace version (2.17.0)
- Lock files committed (Cargo.lock)
- Single source of truth: workspace Cargo.toml

### 1.3 C Header Generation

**cbindgen Configuration (cbindgen.toml):**
```toml
language = "C"
include_guard = "HTML_TO_MARKDOWN_H"
pragma_once = true
header = "/* Auto-generated C bindings for html-to-markdown */"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
documentation = true
line_length = 100

[export]
include = ["html_to_markdown_convert", "html_to_markdown_free_string",
           "html_to_markdown_version", "html_to_markdown_last_error"]
```

**Build Process (build.rs):**
- Generates `html_to_markdown.h` at build time
- Uses cbindgen v0.29
- Automatically triggered on changes to `src/lib.rs` or `cbindgen.toml`

---

## 2. Error Handling Pattern

### 2.2 Thread-Local LAST_ERROR Pattern

**Implementation (error.rs & lib.rs):**

```rust
// Thread-local storage for per-thread errors
thread_local! {
    static LAST_ERROR: RefCell<Option<CString>> = const { RefCell::new(None) };
}

// Set error (called after failed operations)
fn set_last_error(message: Option<String>) {
    LAST_ERROR.with(|cell| {
        let mut slot = cell.borrow_mut();
        *slot = message.and_then(|msg| CString::new(msg).ok());
    });
}

// Retrieve error pointer
fn last_error_ptr() -> *const c_char {
    LAST_ERROR.with(|cell| {
        cell.borrow()
            .as_ref()
            .map(|cstr| cstr.as_ptr() as *const c_char)
            .unwrap_or(ptr::null())
    })
}

// Capture ConversionError from core library
fn capture_error(err: ConversionError) {
    set_last_error(Some(err.to_string()));
}

// Public C API: retrieve last error
#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_last_error() -> *const c_char {
    last_error_ptr()
}
```

### 2.2 Error Flow Pattern

**Typical Error Handling Pattern in FFI Functions:**

```rust
// 1. Input validation (pointer checks)
if html.is_null() {
    set_last_error(Some("html pointer was null".to_string()));
    return ptr::null_mut();
}

// 2. Convert C string to Rust string
let html_str = match unsafe { CStr::from_ptr(html) }.to_str() {
    Ok(s) => s,
    Err(_) => {
        set_last_error(Some("html must be valid UTF-8".to_string()));
        return ptr::null_mut();
    }
};

// 3. Call core library with panic guard
match guard_panic(|| profiling::maybe_profile(|| convert(html_str, None))) {
    Ok(markdown) => {
        set_last_error(None);  // Clear previous errors on success
        // Convert result to CString and return
        match string_to_c_string(markdown, "markdown result") {
            Ok(c_string) => c_string.into_raw(),
            Err(err) => {
                set_last_error(Some(format!("failed to build CString: {err}")));
                ptr::null_mut()
            }
        }
    }
    Err(err) => {
        capture_error(err);     // Capture panic or conversion error
        ptr::null_mut()
    }
}
```

### 2.3 Key Error Handling Features

1. **Thread-safe**: Each thread has its own error buffer
2. **Cleared on success**: `set_last_error(None)` explicitly clears the error
3. **Panic-safe**: Uses `guard_panic()` from core library to catch panics
4. **Null-pointer safe**: All input pointers validated before use
5. **UTF-8 validation**: All C strings validated before Rust conversion

**Example Client Usage Pattern:**
```c
char* result = html_to_markdown_convert(html);
if (result == NULL) {
    const char* error = html_to_markdown_last_error();
    fprintf(stderr, "Error: %s\n", error ? error : "unknown error");
    // error pointer valid only until next FFI call
    return;
}
// Use result
html_to_markdown_free_string(result);
```

---

## 3. String Marshalling Utilities

### 3.1 String Module (strings.rs)

**Utility Functions:**

```rust
/// Convert byte vector to CString, checking for interior null bytes
pub(crate) fn bytes_to_c_string(bytes: Vec<u8>, context: &str) -> Result<CString, String> {
    if bytes.contains(&0) {
        return Err(format!("{context} contained an interior null byte"));
    }
    CString::new(bytes).map_err(|_| format!("{context} contained an interior null byte"))
}

/// Convert Rust String to CString
pub(crate) fn string_to_c_string(value: String, context: &str) -> Result<CString, String> {
    bytes_to_c_string(value.into_bytes(), context)
}
```

### 3.2 In-place C String Conversion

**In lib.rs** (alternative pattern not in strings.rs):
```rust
fn bytes_to_c_string(mut bytes: Vec<u8>, context: &str) -> Result<CString, String> {
    if bytes.contains(&0) {
        return Err(format!("{context} contained an interior null byte"));
    }
    bytes.reserve(1);
    bytes.push(0);
    Ok(unsafe { CString::from_vec_unchecked(bytes) })  // Manual null termination
}
```

### 3.3 String Handling Pattern in FFI Functions

```rust
// 1. C pointer -> Rust &str
let html_str = match unsafe { CStr::from_ptr(html) }.to_str() {
    Ok(s) => s,
    Err(_) => {
        set_last_error(Some("html must be valid UTF-8".to_string()));
        return ptr::null_mut();
    }
};

// 2. Process (core library call)
let markdown = convert(html_str, None)?;

// 3. Rust String -> C CString -> raw pointer
match string_to_c_string(markdown, "markdown result") {
    Ok(c_string) => {
        let ptr = c_string.into_raw();  // Ownership transferred to caller
        ptr
    }
    Err(err) => {
        set_last_error(Some(format!("failed to build CString: {err}")));
        ptr::null_mut()
    }
}

// 4. Caller must free with html_to_markdown_free_string()
```

### 3.4 Memory Management

```rust
/// Free a string returned by FFI functions
#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe { drop(CString::from_raw(s)) };
    }
}
```

**Ownership Transfer Pattern:**
- FFI returns `*mut c_char` (raw pointer) from `CString::into_raw()`
- Caller must call `html_to_markdown_free_string()` to deallocate
- Double-free safe: Function checks `!s.is_null()`

### 3.5 UTF-8 & Encoding Handling

- **Input**: Validates all C strings are valid UTF-8 before conversion to `&str`
- **Output**: Core library returns Rust `String` (always UTF-8), converted to CString
- **Interior nulls**: Explicitly checked; any null byte causes error
- **Empty strings**: Handled correctly (reserve + push 0, or CString::new())

---

## 4. Current Conversion Functions Structure

### 4.1 Basic Conversion (conversion.rs)

**Three Function Tiers:**

1. **Simple C-String API:**
   ```c
   char* html_to_markdown_convert(const char* html);
   ```
   - Input: null-terminated C string
   - Output: null-terminated C string (must be freed)
   - Error: Returns NULL; check `html_to_markdown_last_error()`

2. **With Output Length:**
   ```c
   char* html_to_markdown_convert_with_len(const char* html, uintptr_t* len_out);
   ```
   - Output length written to `len_out`
   - Avoids strlen() overhead in caller

3. **Byte Buffer API:**
   ```c
   char* html_to_markdown_convert_bytes_with_len(
       const uint8_t* html,
       uintptr_t len,
       uintptr_t* len_out
   );
   ```
   - Input: raw byte buffer + length
   - Useful for streaming or pre-sized buffers

### 4.2 Metadata Extraction (metadata.rs, feature-gated)

**Function Signature Pattern:**
```c
char* html_to_markdown_convert_with_metadata(
    const char* html,
    char** metadata_json_out
);

char* html_to_markdown_convert_with_metadata_with_len(
    const char* html,
    char** metadata_json_out,
    uintptr_t* markdown_len_out,
    uintptr_t* metadata_len_out
);

char* html_to_markdown_convert_with_metadata_bytes_with_len(
    const uint8_t* html,
    uintptr_t len,
    char** metadata_json_out,
    uintptr_t* markdown_len_out,
    uintptr_t* metadata_len_out
);
```

**Dual Output Pattern:**
- Returns markdown string pointer
- Writes metadata JSON string pointer to `*metadata_json_out`
- Both must be freed with `html_to_markdown_free_string()`
- On error: Both pointers set to NULL, returns NULL

### 4.3 Utility Functions

```c
// Get library version (static string, no allocation needed)
const char* html_to_markdown_version(void);

// Profiling (feature-gated)
bool html_to_markdown_profile_start(const char* output, int32_t frequency);
bool html_to_markdown_profile_stop(void);

// Error retrieval (thread-local)
const char* html_to_markdown_last_error(void);

// Memory management
void html_to_markdown_free_string(char* s);
```

---

## 5. Profiling & Panic Handling

### 5.1 Profiling Module (profiling.rs)

**Features:**
- `pprof` integration for flamegraph generation
- Unix/Linux only (Windows returns error)
- Optional feature: `profiling`
- Environment variable configuration:
  - `HTML_TO_MARKDOWN_PROFILE_OUTPUT`: flamegraph output file
  - `HTML_TO_MARKDOWN_PROFILE_FREQUENCY`: sampling frequency (default 1000Hz)
  - `HTML_TO_MARKDOWN_PROFILE_ONCE`: profile only first execution
  - `HTML_TO_MARKDOWN_PROFILE_REPEAT`: repeat conversion N times during profiling

**Profile Wrapping:**
```rust
pub fn maybe_profile<T, F>(f: F) -> Result<T> {
    // Checks environment config and wraps conversion in profiler if needed
    // No-op on Windows or with profiling feature disabled
}
```

### 5.2 Panic Safety

**Pattern:**
```rust
use html_to_markdown_rs::safety::guard_panic;

match guard_panic(|| profiling::maybe_profile(|| convert(html_str, None))) {
    Ok(markdown) => { /* success */ }
    Err(err) => { capture_error(err); }  // Catches panics as errors
}
```

**Benefit:**
- Panics in Rust core are caught and converted to `ConversionError`
- FFI layer never panics; always returns NULL + error message
- Safe to call from any language

---

## 6. Dependencies Available

### 6.1 Direct Dependencies

```toml
[dependencies]
html-to-markdown-rs = { workspace = true, features = ["inline-images", "metadata"] }
serde_json = "1.0"

[target.'cfg(not(target_os = "windows"))'.dependencies]
pprof = { version = "0.15", features = ["flamegraph"], optional = true }

[features]
default = ["metadata"]
metadata = ["html-to-markdown-rs/metadata"]
profiling = ["dep:pprof"]
```

### 6.2 Core Library Exports (Available via html-to-markdown-rs)

**From crate root:**
- `ConversionError`: Main error type with From impls
- `convert(html: &str, options: Option<&ConversionOptions>) -> Result<String>`
- `safety::guard_panic(f: F) -> Result<T>`

**From modules (feature-gated):**
- `MetadataConfig`, `convert_with_metadata()` [metadata feature]
- `InlineImage`, `InlineImageConfig` [inline-images feature]

### 6.3 Rust Standard Library Usage

```rust
std::cell::RefCell          // Interior mutability for LAST_ERROR
std::ffi::{CStr, CString}   // C string interop
std::os::raw::c_char        // C char type
std::ptr                    // Pointer utilities
std::slice                  // Raw slice construction
```

---

## 7. Integration Points for Visitor FFI Bridge

### 7.1 Where to Add Visitor Module

**Proposed Structure:**
```
crates/html-to-markdown-ffi/src/
├── visitor.rs            # NEW: FFI bindings for visitor API
├── visitor_config.rs     # NEW: Opaque visitor handles for C layer
└── lib.rs                # Include visitor module, add new exports
```

### 7.2 Visitor Module in Core Library

**Location:** `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown/src/visitor.rs`

**Current Structure:**
- `NodeType` enum: 60+ HTML element types
- `NodeContext` struct: Element metadata (tag, attributes, depth, parent info)
- `VisitResult` enum: Continue, Custom, Skip, PreserveHtml, Error
- `HtmlVisitor` trait: 60+ visitor methods (all with default Continue impl)

**Example Methods:**
```rust
fn visit_element_start(&mut self, ctx: &NodeContext) -> VisitResult
fn visit_element_end(&mut self, ctx: &NodeContext, output: &str) -> VisitResult
fn visit_text(&mut self, ctx: &NodeContext, text: &str) -> VisitResult
fn visit_link(&mut self, ctx: &NodeContext, href: &str, text: &str, title: Option<&str>) -> VisitResult
fn visit_image(&mut self, ctx: &NodeContext, src: &str, alt: &str, title: Option<&str>) -> VisitResult
fn visit_heading(&mut self, ctx: &NodeContext, level: u32, text: &str, id: Option<&str>) -> VisitResult
// ... and 50+ more
```

### 7.3 Feature Requirement

**Core Library (Cargo.toml):**
- Visitor module is already defined but feature-gated: `#[cfg(feature = "visitor")]`
- Feature must be enabled in FFI crate's dependency

**Proposed FFI Update (Cargo.toml):**
```toml
[dependencies]
html-to-markdown-rs = {
    workspace = true,
    features = ["inline-images", "metadata", "visitor"]  # Add "visitor"
}
```

### 7.4 Type Marshalling Challenges

**Rust → C Type Mapping Required:**

| Rust Type | C Equivalent | Challenge |
|-----------|-------------|-----------|
| `HtmlVisitor` trait | Opaque `void*` handle | Trait objects not C-compatible |
| `NodeContext` struct | `struct html_to_markdown_node_context` | Copy all fields |
| `BTreeMap<String, String>` (attrs) | `const char** keys, const char** values, uintptr_t count` | Marshal map to arrays |
| `VisitResult` enum | `int` (enum discriminant) | Custom handling for `Custom(String)` |
| Callback results | Output buffer + length | Reverse marshalling for Custom output |

### 7.5 Callback Registration Pattern

**Likely Pattern (similar to C FFI libraries):**

```c
// Opaque visitor handle created from callbacks
typedef struct HTMLToMarkdownVisitor* VisitorHandle;

// Callback function pointers
typedef int (*VisitElementStartFn)(VisitorHandle visitor, const char* tag, const char** attr_keys, const char** attr_values, uintptr_t attr_count, int node_type, uintptr_t depth);

typedef int (*VisitTextFn)(VisitorHandle visitor, const char* text);

// Create visitor from callbacks
VisitorHandle html_to_markdown_visitor_create(
    VisitElementStartFn on_element_start,
    VisitElementEndFn on_element_end,
    VisitTextFn on_text,
    // ... more callback pointers
    void* user_data  // Opaque context for callbacks
);

// Convert with visitor
char* html_to_markdown_convert_with_visitor(
    const char* html,
    VisitorHandle visitor
);

// Cleanup
void html_to_markdown_visitor_free(VisitorHandle visitor);
```

---

## 8. Current Test Coverage

### 8.1 FFI Tests (tests.rs in lib.rs)

**Test Patterns:**
- `test_basic_conversion()`: Simple HTML→Markdown
- `test_null_html()`: Null pointer handling
- `test_last_error_clears_after_success()`: Error state management
- `test_convert_with_len_reports_length()`: Output length reporting
- `test_convert_with_metadata_*()`: Metadata extraction (10+ tests)
- `test_convert_with_metadata_unicode_handling()`: UTF-8 edge cases

**Example Test:**
```rust
#[test]
fn test_basic_conversion() {
    unsafe {
        let html = CString::new("<h1>Hello World</h1>").unwrap();
        let result = html_to_markdown_convert(html.as_ptr());
        assert!(!result.is_null());
        let markdown = CStr::from_ptr(result).to_str().unwrap();
        assert!(markdown.contains("Hello World"));
        html_to_markdown_free_string(result);
    }
}
```

### 8.2 What's NOT Tested

- Multi-threaded error access (LAST_ERROR thread-safety)
- Profiling integration
- Byte buffer API (convert_bytes_with_len)
- Panic handling

---

## 9. Key Architectural Patterns to Follow

### 9.1 Null-Pointer Safety

**Check all input pointers:**
```rust
if ptr.is_null() {
    set_last_error(Some("description pointer was null".to_string()));
    return ptr::null_mut();
}
```

### 9.2 UTF-8 Validation

**Always validate C strings:**
```rust
let str = match unsafe { CStr::from_ptr(c_str) }.to_str() {
    Ok(s) => s,
    Err(_) => {
        set_last_error(Some("input must be valid UTF-8".to_string()));
        return ptr::null_mut();
    }
};
```

### 9.3 Error Clearing on Success

**Clear errors when successful:**
```rust
set_last_error(None);  // Must do this before returning success
```

### 9.4 Panic Wrapping

**Wrap all core calls:**
```rust
match guard_panic(|| profiling::maybe_profile(|| some_operation())) {
    Ok(result) => { /* handle success */ }
    Err(err) => { capture_error(err); }
}
```

### 9.5 String Marshalling Pattern

```rust
match string_to_c_string(rust_string, "context") {
    Ok(c_string) => c_string.into_raw(),  // Return ownership to caller
    Err(err) => {
        set_last_error(Some(format!("failed to convert: {err}")));
        ptr::null_mut()
    }
}
```

### 9.6 Opaque Handle Pattern

**For complex types (like visitors):**
```rust
#[repr(C)]
pub struct VisitorHandle {
    // Private fields
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_visitor_create(...) -> *mut VisitorHandle {
    // Create and return boxed visitor
    Box::into_raw(Box::new(VisitorHandle { ... }))
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_visitor_free(handle: *mut VisitorHandle) {
    if !handle.is_null() {
        let _ = Box::from_raw(handle);  // Deallocate
    }
}
```

---

## 10. Header Generation & Export Configuration

### 10.1 cbindgen Export List

**Current (cbindgen.toml):**
```toml
[export]
include = ["html_to_markdown_convert", "html_to_markdown_free_string",
           "html_to_markdown_version", "html_to_markdown_last_error"]
```

**For Visitor Module, Must Add:**
- `html_to_markdown_visitor_create`
- `html_to_markdown_visitor_free`
- `html_to_markdown_convert_with_visitor`
- Callback function pointer types (VisitElementStartFn, etc.)
- NodeContext struct (or C equivalent)
- VisitResult enum (or int enum)

### 10.2 Documentation in Generated Header

**Pattern:** rustdoc comments → C comments
```rust
/// Convert HTML to Markdown with visitor hooks.
///
/// # Safety
/// ...
#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_convert_with_visitor(...) -> *mut c_char {
    // ...
}
```

---

## 11. Implementation Recommendations for Visitor FFI

### 11.1 New Module: `visitor.rs`

**Responsibilities:**
1. Opaque `VisitorHandle` type for C FFI
2. Callback function pointer types (for each visitor method)
3. Visitor creation/destruction functions
4. Convert visitor to `VisitorHandle` for internal use
5. Wrap all visitor calls with `guard_panic()`

### 11.2 Type Definitions for C

```rust
// Opaque handle for visitor
pub struct VisitorHandle {
    visitor: Rc<RefCell<dyn HtmlVisitor>>,
    user_data: *mut c_void,
}

// Callback signatures
pub type VisitElementStartFn = unsafe extern "C" fn(
    handle: *mut VisitorHandle,
    tag: *const c_char,
    attr_keys: *const *const c_char,
    attr_values: *const *const c_char,
    attr_count: usize,
    node_type: i32,
    depth: usize,
) -> i32;  // VisitResult discriminant

// ... more callback types
```

### 11.3 Integration with Existing Conversion Functions

**New function signature:**
```rust
#[unsafe(no_mangle)]
pub unsafe extern "C" fn html_to_markdown_convert_with_visitor(
    html: *const c_char,
    visitor: *mut VisitorHandle,
) -> *mut c_char {
    // Existing error handling + null checks
    // Extract visitor, call core with visitor
    // Handle VisitResult enums
}
```

### 11.4 Configuration for cbindgen

**Update cbindgen.toml:**
```toml
[export]
include = [
    "html_to_markdown_convert",
    "html_to_markdown_free_string",
    "html_to_markdown_version",
    "html_to_markdown_last_error",
    "html_to_markdown_visitor_create",
    "html_to_markdown_visitor_free",
    "html_to_markdown_convert_with_visitor",
    "VisitorHandle",
    "NodeContext",
]
```

### 11.5 Test Structure

**New tests:**
- `test_visitor_create_and_free()`: Handle lifecycle
- `test_visitor_callback_fired()`: Callback invocation
- `test_visitor_skip_result()`: VisitResult::Skip handling
- `test_visitor_custom_result()`: VisitResult::Custom output
- `test_visitor_error_result()`: VisitResult::Error handling

---

## 12. Build & Distribution

### 12.1 Cargo Build Output

**Release Build:**
```bash
cargo build -p html-to-markdown-ffi --release
```

**Artifacts:**
- Unix/Linux: `target/release/libhtml_to_markdown_ffi.so`
- macOS: `target/release/libhtml_to_markdown_ffi.dylib`
- Windows: `target/release/html_to_markdown_ffi.dll`
- All platforms: `target/release/libhtml_to_markdown_ffi.a` (static lib)
- C Headers: `crates/html-to-markdown-ffi/html_to_markdown.h`

### 12.2 Integration with Language Bindings

**Pattern for Go, Java, C# bindings:**
1. Link to FFI library (dynamic or static)
2. Import generated C header
3. Implement language-specific wrappers
4. Test with integration suite

---

## Summary: Key Takeaways

1. **Thread-Safe Error Handling**: Thread-local `LAST_ERROR` with explicit clearing on success
2. **Panic-Safe**: All core operations wrapped in `guard_panic()`
3. **String Marshalling**: UTF-8 validation, interior null-byte checking, ownership transfer
4. **Opaque Handles**: Complex types (future visitors) use `*mut void` or struct wrappers
5. **Three API Tiers**: Simple, with-length, bytes variants for flexibility
6. **Feature Gates**: Use cargo features for optional functionality
7. **Header Generation**: cbindgen auto-generates C header; export list controls visibility
8. **Memory Safety**: All allocations owned by caller via `html_to_markdown_free_string()`
9. **Callback Pattern**: Function pointers + opaque user data for visitor-like patterns
10. **No Duplication**: Core logic always in Rust; FFI is thin marshalling layer

---

## Files Reference

**Key Implementation Files:**
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/src/lib.rs` - Main FFI exports
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/src/error.rs` - Error handling
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/src/strings.rs` - String utilities
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/src/conversion.rs` - Basic conversion
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/src/metadata.rs` - Metadata FFI
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/cbindgen.toml` - C header config

**Core Library Files:**
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown/src/visitor.rs` - Visitor trait (60+ methods)
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown/src/lib.rs` - Module exports

**Configuration:**
- `/Users/naamanhirschfeld/workspace/html-to-markdown/Cargo.toml` - Workspace & versions
- `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/Cargo.toml` - FFI dependencies

---

**Generated C Header**: `/Users/naamanhirschfeld/workspace/html-to-markdown/crates/html-to-markdown-ffi/html_to_markdown.h`
