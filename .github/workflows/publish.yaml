name: Publish Release

on:
  workflow_run:
    workflows: ["Build Artifacts"]
    types: [completed]

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.workflow_run.id }}
  cancel-in-progress: false

jobs:
  gather:
    name: Load release metadata
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.read.outputs.tag }}
      version: ${{ steps.read.outputs.version }}
      ref: ${{ steps.read.outputs.ref }}
      dry_run: ${{ steps.dryrun.outputs.value }}
      build_run_id: ${{ steps.build_run.outputs.id }}
      is_tag: ${{ steps.ref_type.outputs.is_tag }}
    steps:
      - name: Determine build run
        id: build_run
        run: |
          echo "id=${{ github.event.workflow_run.id }}" >> "$GITHUB_OUTPUT"

      - name: Download metadata artifact
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ steps.build_run.outputs.id }}
          name: release-metadata
          path: metadata
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read metadata
        id: read
        run: |
          set -euo pipefail
          metadata="metadata/release-metadata.json"
          if [ ! -f "$metadata" ]; then
            echo "Metadata artifact not found" >&2
            exit 1
          fi
          python - >> "$GITHUB_OUTPUT" <<'PY'
          import json, os
          with open('metadata/release-metadata.json', 'r', encoding='utf-8') as fh:
              data = json.load(fh)
          print(f"tag={data['tag']}")
          print(f"version={data['version']}")
          print(f"ref={data['ref']}")
          print(f"dry_run={str(data.get('dry_run', False)).lower()}")
          PY

      - name: Determine dry-run flag
        id: dryrun
        run: |
          echo "value=${{ steps.read.outputs.dry_run }}" >> "$GITHUB_OUTPUT"

      - name: Determine reference type
        id: ref_type
        run: |
          ref="${{ steps.read.outputs.ref }}"
          if [[ "$ref" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "is_tag=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_tag=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Summarize release
        run: |
          echo "### Release metadata" >> $GITHUB_STEP_SUMMARY
          echo "- Build run ID: ${{ steps.build_run.outputs.id }}" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: ${{ steps.read.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ steps.read.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Dry run: ${{ steps.dryrun.outputs.value }}" >> $GITHUB_STEP_SUMMARY
          echo "- Reference: ${{ steps.read.outputs.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- Reference is tag: ${{ steps.ref_type.outputs.is_tag }}" >> $GITHUB_STEP_SUMMARY

  publish-crates:
    name: Publish crates.io packages
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.gather.outputs.ref }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Verify Cargo.toml version matches tag
        run: |
          cargo_version=$(grep '^version = ' Cargo.toml | head -1 | sed -E 's/version = "(.*)"/\1/')
          tag_version="${{ needs.gather.outputs.version }}"
          if [ "$cargo_version" != "$tag_version" ]; then
            echo "Version mismatch! Cargo: $cargo_version, tag: $tag_version" >&2
            exit 1
          fi
          echo "Cargo.toml version matches tag: $cargo_version"

      - name: Check crates.io for existing release
        id: crate_check
        env:
          VERSION: ${{ needs.gather.outputs.version }}
        run: |
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          import sys
          import urllib.request
          version = os.environ["VERSION"]
          crates = [
              ("html-to-markdown-rs", "rs_exists"),
              ("html-to-markdown-cli", "cli_exists"),
          ]
          for crate, key in crates:
              url = f"https://crates.io/api/v1/crates/{crate}"
              try:
                  with urllib.request.urlopen(url) as resp:
                      data = json.load(resp)
              except Exception as exc:  # pragma: no cover
                  print(f"::warning::{crate}: failed to query crates.io ({exc})", file=sys.stderr)
                  exists = False
              else:
                  versions = [item.get("num") for item in data.get("versions", [])]
                  exists = version in versions
                  message = "already" if exists else "not yet"
                  print(f"::notice::{crate} {version} {message} published", file=sys.stderr)
              print(f"{key}={'true' if exists else 'false'}")
          PY

      - name: Publish html-to-markdown-rs
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: cargo publish -p html-to-markdown-rs --token ${{ secrets.CARGO_TOKEN }}

      - name: Wait for indexing
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: sleep 30

      - name: Publish html-to-markdown-cli
        if: ${{ steps.crate_check.outputs.cli_exists != 'true' }}
        run: cargo publish -p html-to-markdown-cli --token ${{ secrets.CARGO_TOKEN }}

  publish-pypi:
    name: Publish Python packages to PyPI
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      id-token: write
    steps:
      - name: Download wheel artifacts
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: python-wheels-*
          path: dist
          merge-multiple: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download sdist artifact
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          name: python-sdist
          path: dist
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: List artifacts
        run: ls -R dist

      - name: Publish to PyPI
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist

      - name: Dry run summary
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; artifacts staged for PyPI:" >> $GITHUB_STEP_SUMMARY
          ls -1 dist >> $GITHUB_STEP_SUMMARY

  publish-rubygems:
    name: Publish Ruby gems
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Download Ruby gem artifacts
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: rubygems-*
          path: dist
          merge-multiple: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure trusted publishing credentials
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        uses: rubygems/configure-rubygems-credentials@v1.0.0

      - name: Publish gems
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        working-directory: dist
        run: |
          set -euo pipefail
          shopt -s nullglob
          gems=($(ls html-to-markdown-*.gem | sort))
          if [ ${#gems[@]} -eq 0 ]; then
            echo "No gem artifacts found" >&2
            exit 1
          fi
          for gem in "${gems[@]}"; do
            echo "Pushing ${gem}"
            gem push "$gem"
          done

      - name: Dry run summary
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        working-directory: dist
        run: |
          echo "Dry run requested; gem artifacts ready:" >> $GITHUB_STEP_SUMMARY
          ls -1 html-to-markdown-*.gem >> $GITHUB_STEP_SUMMARY

  publish-node:
    name: Publish Node packages
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.gather.outputs.ref }}

      - name: Download Node artifacts
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: node-bindings-*
          path: node-artifacts
          merge-multiple: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Enable corepack
        run: corepack enable

      - name: Prepare artifact directory
        run: |
          rm -rf crates/html-to-markdown-node/npm
          mkdir -p crates/html-to-markdown-node
          for pkg in node-artifacts/*.tar.gz; do
            tar -xzf "$pkg" -C crates/html-to-markdown-node
          done

      - name: Node artifacts summary
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; Node binding tarballs staged:" >> $GITHUB_STEP_SUMMARY
          find node-artifacts -name '*.tar.gz' -printf '%f\n' >> $GITHUB_STEP_SUMMARY

      - name: Install workspace dependencies
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        run: pnpm install --filter html-to-markdown-node...

      - name: Publish native binary packages
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          for pkg in crates/html-to-markdown-node/npm/**/*.tgz crates/html-to-markdown-node/npm/*.tgz; do
            echo "Publishing $pkg"
            npm publish "$pkg" --access public --ignore-scripts
          done

      - name: Publish main Node package
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          cd crates/html-to-markdown-node
          pnpm publish --access public --no-git-checks

  publish-php-windows:
    name: Upload Windows extension artifacts
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.gather.outputs.ref }}

      - name: Download Windows artifacts
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: php_html_to_markdown-*.zip
          path: dist/php-windows
          merge-multiple: true
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: List Windows artifacts
        run: find dist/php-windows -maxdepth 1 -type f -name 'php_html_to_markdown-*.zip' -print

      - name: Upload Windows assets
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          shopt -s nullglob
          files=(dist/php-windows/php_html_to_markdown-*.zip)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No Windows artifacts to upload" >&2
            exit 1
          fi
          for file in "${files[@]}"; do
            gh release upload ${{ needs.gather.outputs.tag }} "$file" --clobber
          done

      - name: Record Windows dry run artifacts
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; Windows packages staged:" >> $GITHUB_STEP_SUMMARY
          find dist/php-windows -maxdepth 1 -type f -name 'php_html_to_markdown-*.zip' -printf '%f\n' >> $GITHUB_STEP_SUMMARY

  publish-php-pie:
    name: Upload PIE source archive
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' && needs.gather.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.gather.outputs.ref }}

      - name: Download PIE source artifact
        uses: actions/download-artifact@v6
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          name: php-pie-src
          path: dist/php-pie
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: List PIE artifact contents
        run: ls -R dist/php-pie

      - name: Upload PIE source to release
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ needs.gather.outputs.tag }} dist/php-pie/php_html_to_markdown-${{ needs.gather.outputs.version }}-src.tgz --clobber

      - name: Record dry-run bundle location
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; PIE source archive staged locally:" >> $GITHUB_STEP_SUMMARY
          ls -1 dist/php-pie >> $GITHUB_STEP_SUMMARY

  concluded:
    if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion != 'success' }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Build workflow did not succeed (status: ${{ github.event.workflow_run.conclusion }}). Skipping publish." >> $GITHUB_STEP_SUMMARY
