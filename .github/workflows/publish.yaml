name: Publish Release

on:
  workflow_run:
    workflows: ["Build Artifacts"]
    types: [completed]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (e.g., v2.6.0)"
        required: true
        type: string
      build_run_id:
        description: "Workflow run ID from the Build Artifacts workflow"
        required: true
        type: string
      dry_run:
        description: "Dry run (validate artifacts without publishing)"
        required: false
        type: boolean
        default: true

concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'workflow_dispatch' && inputs.build_run_id || github.event.workflow_run.id }}
  cancel-in-progress: false

jobs:
  gather:
    name: Load release metadata
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.read.outputs.tag }}
      version: ${{ steps.read.outputs.version }}
      ref: ${{ steps.read.outputs.ref }}
      dry_run: ${{ steps.dryrun.outputs.value }}
      build_run_id: ${{ steps.build_run.outputs.id }}
    steps:
      - name: Determine build run
        id: build_run
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            id="${{ inputs.build_run_id }}"
            if [ -z "$id" ]; then
              echo "build_run_id input is required when manually dispatching this workflow." >&2
              exit 1
            fi
          else
            id="${{ github.event.workflow_run.id }}"
          fi
          echo "id=$id" >> "$GITHUB_OUTPUT"

      - name: Download metadata artifact
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ steps.build_run.outputs.id }}
          name: release-metadata
          path: metadata

      - name: Read metadata
        id: read
        run: |
          set -euo pipefail
          metadata="metadata/release-metadata.json"
          if [ ! -f "$metadata" ]; then
            echo "Metadata artifact not found" >&2
            exit 1
          fi
          python - <<'PY'
import json, os
with open('metadata/release-metadata.json', 'r', encoding='utf-8') as fh:
    data = json.load(fh)
print(f"tag={data['tag']}")
print(f"version={data['version']}")
print(f"ref={data['ref']}")
print(f"dry_run={str(data.get('dry_run', False)).lower()}")
PY >> "$GITHUB_OUTPUT"

      - name: Determine dry-run flag
        id: dryrun
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ inputs.tag }}" != "${{ steps.read.outputs.tag }}" ]; then
              echo "Specified tag '${{ inputs.tag }}' does not match metadata tag '${{ steps.read.outputs.tag }}'." >&2
              exit 1
            fi
            echo "value=${{ inputs.dry_run }}" >> "$GITHUB_OUTPUT"
          else
            echo "value=${{ steps.read.outputs.dry_run }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Summarize release
        run: |
          echo "### Release metadata" >> $GITHUB_STEP_SUMMARY
          echo "- Build run ID: ${{ steps.build_run.outputs.id }}" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: ${{ steps.read.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ steps.read.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Dry run: ${{ steps.dryrun.outputs.value }}" >> $GITHUB_STEP_SUMMARY

  publish-crates:
    name: Publish crates.io packages
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag && needs.gather.outputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.gather.outputs.ref }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Verify Cargo.toml version matches tag
        run: |
          cargo_version=$(grep '^version = ' Cargo.toml | head -1 | sed -E 's/version = "(.*)"/\1/')
          tag_version="${{ needs.gather.outputs.version }}"
          if [ "$cargo_version" != "$tag_version" ]; then
            echo "Version mismatch! Cargo: $cargo_version, tag: $tag_version" >&2
            exit 1
          fi
          echo "Cargo.toml version matches tag: $cargo_version"

      - name: Check crates.io for existing release
        id: crate_check
        env:
          VERSION: ${{ needs.gather.outputs.version }}
        run: |
          python - <<'PY' >> "$GITHUB_OUTPUT"
import json
import os
import sys
import urllib.request
version = os.environ["VERSION"]
crates = [
    ("html-to-markdown-rs", "rs_exists"),
    ("html-to-markdown-cli", "cli_exists"),
]
for crate, key in crates:
    url = f"https://crates.io/api/v1/crates/{crate}"
    try:
        with urllib.request.urlopen(url) as resp:
            data = json.load(resp)
    except Exception as exc:  # pragma: no cover
        print(f"::warning::{crate}: failed to query crates.io ({exc})", file=sys.stderr)
        exists = False
    else:
        versions = [item.get("num") for item in data.get("versions", [])]
        exists = version in versions
        message = "already" if exists else "not yet"
        print(f"::notice::{crate} {version} {message} published", file=sys.stderr)
    print(f"{key}={'true' if exists else 'false'}")
PY

      - name: Publish html-to-markdown-rs
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: cargo publish -p html-to-markdown-rs --token ${{ secrets.CARGO_TOKEN }}

      - name: Wait for indexing
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: sleep 30

      - name: Publish html-to-markdown-cli
        if: ${{ steps.crate_check.outputs.cli_exists != 'true' }}
        run: cargo publish -p html-to-markdown-cli --token ${{ secrets.CARGO_TOKEN }}

  publish-pypi:
    name: Publish Python packages to PyPI
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag }}
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      id-token: write
    steps:
      - name: Download wheel artifacts
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: python-wheels-*
          path: dist
          merge-multiple: true

      - name: Download sdist artifact
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          name: python-sdist
          path: dist

      - name: List artifacts
        run: ls -R dist

      - name: Publish to PyPI
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist

      - name: Dry run summary
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; artifacts staged for PyPI:" >> $GITHUB_STEP_SUMMARY
          ls -1 dist >> $GITHUB_STEP_SUMMARY

  publish-rubygems:
    name: Publish Ruby gems
    needs: gather
    if: ${{ needs.gather.result == 'success' && needs.gather.outputs.tag }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Download Ruby gem artifacts
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ needs.gather.outputs.build_run_id }}
          pattern: rubygems-*
          path: dist
          merge-multiple: true

      - name: Configure trusted publishing credentials
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        uses: rubygems/configure-rubygems-credentials@v1.0.0

      - name: Publish gems
        if: ${{ needs.gather.outputs.dry_run != 'true' }}
        working-directory: dist
        run: |
          set -euo pipefail
          shopt -s nullglob
          gems=($(ls html-to-markdown-*.gem | sort))
          if [ ${#gems[@]} -eq 0 ]; then
            echo "No gem artifacts found" >&2
            exit 1
          fi
          for gem in "${gems[@]}"; do
            echo "Pushing ${gem}"
            gem push "$gem"
          done

      - name: Dry run summary
        if: ${{ needs.gather.outputs.dry_run == 'true' }}
        working-directory: dist
        run: |
          echo "Dry run requested; gem artifacts ready:" >> $GITHUB_STEP_SUMMARY
          ls -1 html-to-markdown-*.gem >> $GITHUB_STEP_SUMMARY

  concluded:
    if: ${{ github.event.workflow_run.conclusion != 'success' }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Build workflow did not succeed (status: ${{ github.event.workflow_run.conclusion }}). Skipping publish." >> $GITHUB_STEP_SUMMARY
