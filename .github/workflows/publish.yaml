name: Publish Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to build (e.g., v2.6.0)"
        required: true
        type: string
      dry_run:
        description: "Prepare artifacts without publishing"
        required: false
        type: boolean
        default: false
      ref:
        description: "Git ref (branch, tag, or commit) to build; defaults to the tag"
        required: false
        type: string
  push:
    tags:
      - "v*"
  release:
    types: [published]
  repository_dispatch:
    types: [publish-release]

concurrency:
  group: ${{ github.workflow }}-${{ (github.event_name == 'workflow_dispatch' && (github.event.inputs.ref || github.event.inputs.tag)) || github.ref || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    name: Prepare metadata
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}
      ref: ${{ steps.meta.outputs.ref }}
      dry_run: ${{ steps.meta.outputs.dry_run }}
      checkout_ref: ${{ steps.meta.outputs.checkout_ref }}
      target_sha: ${{ steps.meta.outputs.target_sha }}
      matrix_ref: ${{ steps.meta.outputs.matrix_ref }}
      is_tag: ${{ steps.meta.outputs.is_tag }}
    steps:
      - name: Validate tag and compute version
        id: meta
        run: |
          event="${{ github.event_name }}"
          if [[ "$event" == "workflow_dispatch" ]]; then
            tag="${{ inputs.tag }}"
            dry_run_input="${{ inputs.dry_run }}"
            ref_input="${{ inputs.ref }}"
          elif [[ "$event" == "release" ]]; then
            tag="${{ github.event.release.tag_name }}"
            dry_run_input="false"
            ref_input="refs/tags/${tag}"
          elif [[ "$event" == "repository_dispatch" ]]; then
            tag="${{ github.event.client_payload.tag }}"
            dry_run_input="${{ github.event.client_payload.dry_run }}"
            ref_input="${{ github.event.client_payload.ref }}"
          else
            tag="${GITHUB_REF_NAME}"
            dry_run_input="false"
            ref_input=""
            if [[ "$tag" == *-pre* ]]; then
              dry_run_input="true"
            fi
          fi
          if [[ -z "$tag" ]]; then
            echo "Release tag could not be determined" >&2
            exit 1
          fi
          if [[ "$tag" != v* ]]; then
            echo "Tag must start with 'v' (e.g., v2.6.0)" >&2
            exit 1
          fi
          version="${tag#v}"
          if [[ -n "$ref_input" ]]; then
            ref="$ref_input"
          else
            ref="refs/tags/${tag}"
          fi
          if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
            checkout_ref="refs/heads/main"
            target_sha="$ref"
          elif [[ "$ref" =~ ^refs/ ]]; then
            checkout_ref="$ref"
            target_sha=""
          else
            checkout_ref="refs/heads/${ref}"
            target_sha=""
          fi
          if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
            matrix_ref="main"
          elif [[ "$ref" =~ ^refs/heads/(.+)$ ]]; then
            matrix_ref="${BASH_REMATCH[1]}"
          elif [[ "$ref" =~ ^refs/tags/(.+)$ ]]; then
            matrix_ref="${BASH_REMATCH[1]}"
          else
            matrix_ref="$ref"
          fi
          dry_run="$dry_run_input"

          # Determine if this is a tag push
          if [[ "$ref" =~ ^refs/tags/ ]]; then
            is_tag="true"
          else
            is_tag="false"
          fi

          cat <<JSON > release-metadata.json
          {
            "tag": "$tag",
            "version": "$version",
            "ref": "$ref",
            "checkout_ref": "$checkout_ref",
            "target_sha": "$target_sha",
            "matrix_ref": "$matrix_ref",
            "dry_run": ${dry_run:-false},
            "is_tag": $is_tag
          }
          JSON
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "ref=$ref" >> "$GITHUB_OUTPUT"
          echo "dry_run=${dry_run:-false}" >> "$GITHUB_OUTPUT"
          echo "checkout_ref=$checkout_ref" >> "$GITHUB_OUTPUT"
          echo "target_sha=$target_sha" >> "$GITHUB_OUTPUT"
          echo "matrix_ref=$matrix_ref" >> "$GITHUB_OUTPUT"
          echo "is_tag=$is_tag" >> "$GITHUB_OUTPUT"
      - name: Upload release metadata
        uses: actions/upload-artifact@v5
        with:
          name: release-metadata
          path: release-metadata.json
          retention-days: 14

  python-wheels:
    name: Build Python wheels (${{ matrix.os }})
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Build wheels
        uses: ./.github/actions/build-wheels
        with:
          python-version: "3.13"

      - name: Upload wheels
        uses: actions/upload-artifact@v5
        with:
          name: python-wheels-${{ matrix.os }}
          path: wheelhouse/*.whl
          retention-days: 14

  python-sdist:
    name: Build Python sdist
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install maturin

      - name: Build CLI binary for sdist
        run: cargo build --release --package html-to-markdown-cli

      - name: Prepare sdist with CLI
        run: python scripts/prepare_wheel.py

      - name: Build sdist
        working-directory: packages/python
        run: maturin sdist --out dist/

      - name: Upload sdist
        uses: actions/upload-artifact@v5
        with:
          name: python-sdist
          path: packages/python/dist/*.tar.gz
          retention-days: 14

  php-pie:
    name: Build PHP PIE source bundle
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Set up PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.3"
          tools: composer:2.9.1
          coverage: none

      - name: Ensure packaging script is executable
        run: chmod +x scripts/package_php_pie_source.sh

      - name: Assemble PIE source archive
        run: ./scripts/package_php_pie_source.sh ${{ needs.prepare.outputs.version }} build/artifacts

      - name: Download PIE CLI
        run: |
          curl -fsSL https://github.com/php/pie/releases/latest/download/pie.phar -o build/pie.phar

      - name: Verify PIE build from archive
        run: |
          set -euo pipefail
          TMP_DIR=$(mktemp -d)
          tar -xzf "build/artifacts/php_html_to_markdown-${{ needs.prepare.outputs.version }}-src.tgz" -C "$TMP_DIR"
          echo "Extracted archive contents:" && ls -R "$TMP_DIR"
          php build/pie.phar repository:add path "$TMP_DIR"
          CARGO_BIN="$(command -v cargo)"
          php build/pie.phar build goldziher/html-to-markdown:*@dev --working-dir "$TMP_DIR" --with-cargo-bin="$CARGO_BIN"

      - name: Upload PIE source archive
        uses: actions/upload-artifact@v5
        with:
          name: php-pie-src
          path: build/artifacts/php_html_to_markdown-${{ needs.prepare.outputs.version }}-src.tgz
          retention-days: 14

  node-typescript-defs:
    name: Generate Node TypeScript definitions
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          check-latest: true

      - name: Enable corepack
        run: corepack enable

      - name: Install Node dependencies
        run: pnpm install --filter html-to-markdown-node...

      - name: Generate TypeScript definitions
        run: |
          # Build without --platform to generate index.d.ts
          pnpm --filter html-to-markdown-node exec napi build --release
          # Copy index.js (committed) and index.d.ts (generated)
          mkdir -p typescript-defs
          cp crates/html-to-markdown-node/index.js crates/html-to-markdown-node/index.d.ts typescript-defs/

      - name: Upload TypeScript definitions
        uses: actions/upload-artifact@v5
        with:
          name: node-typescript-defs
          path: typescript-defs/
          retention-days: 14

  node-bindings:
    name: Build Node bindings (${{ matrix.target }})
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-14
            target: aarch64-apple-darwin
            rust_target: ""
            use_cross: false
            use_napi_cross: false
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            rust_target: ""
            use_cross: false
            use_napi_cross: false
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            rust_target: x86_64-unknown-linux-musl
            use_cross: true
            use_napi_cross: false
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            rust_target: aarch64-unknown-linux-gnu
            use_cross: false
            use_napi_cross: true
          - os: ubuntu-latest
            target: aarch64-unknown-linux-musl
            rust_target: aarch64-unknown-linux-musl
            use_cross: true
            use_napi_cross: false
          - os: ubuntu-latest
            target: armv7-unknown-linux-gnueabihf
            rust_target: armv7-unknown-linux-gnueabihf
            use_cross: false
            use_napi_cross: true
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            rust_target: ""
            use_cross: false
            use_napi_cross: false
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            rust_target: aarch64-pc-windows-msvc
            use_cross: false
            use_napi_cross: false
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Add Rust target
        if: ${{ matrix.rust_target != '' }}
        run: rustup target add ${{ matrix.rust_target }}

      - name: Install cross
        if: ${{ matrix.use_cross }}
        run: cargo install cross --git https://github.com/cross-rs/cross --locked

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          check-latest: true

      - name: Enable corepack
        run: corepack enable

      - name: Install Node dependencies
        run: pnpm install --filter html-to-markdown-node...

      - name: Clean npm directory
        if: runner.os != 'Windows'
        run: rm -rf crates/html-to-markdown-node/npm

      - name: Clean npm directory (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: Remove-Item -Recurse -Force crates/html-to-markdown-node\npm -ErrorAction SilentlyContinue

      - name: Create npm package structure
        run: pnpm --filter html-to-markdown-node exec napi create-npm-dirs

      - name: Build native module
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.target }}
          USE_CROSS: ${{ matrix.use_cross }}
          USE_NAPI_CROSS: ${{ matrix.use_napi_cross }}
        shell: bash
        run: |
          set -euo pipefail
          args=(--platform --release --target "$TARGET" --output-dir ./artifacts)
          if [ "${USE_NAPI_CROSS}" = "true" ]; then
            args+=(--use-napi-cross)
          fi
          if [ "${USE_CROSS}" = "true" ]; then
            args+=(--use-cross)
          fi
          pnpm --filter html-to-markdown-node exec napi build "${args[@]}"

      - name: Build native module (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          TARGET: ${{ matrix.target }}
          USE_CROSS: ${{ matrix.use_cross }}
          USE_NAPI_CROSS: ${{ matrix.use_napi_cross }}
        run: |
          $args = @('--platform', '--release', '--target', $env:TARGET, '--output-dir', './artifacts')
          if ($env:USE_NAPI_CROSS -eq 'true') { $args += '--use-napi-cross' }
          if ($env:USE_CROSS -eq 'true') { $args += '--use-cross' }
          pnpm --filter html-to-markdown-node exec napi build @args

      - name: Package artifacts
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.target }}
        run: |
          pnpm --filter html-to-markdown-node exec napi artifacts --output-dir ./artifacts
          test -d crates/html-to-markdown-node/npm || { echo "npm artifact directory missing"; exit 1; }
          tar -czf node-bindings-$TARGET.tar.gz -C crates/html-to-markdown-node npm

      - name: Package artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          TARGET: ${{ matrix.target }}
        run: |
          pnpm --filter html-to-markdown-node exec napi artifacts --output-dir ./artifacts
          if (-Not (Test-Path crates/html-to-markdown-node\npm)) { throw "npm artifact directory missing" }
          tar -czf node-bindings-$env:TARGET.tar.gz -C crates/html-to-markdown-node npm

      - name: Upload Node artifact
        uses: actions/upload-artifact@v5
        with:
          name: node-bindings-${{ matrix.target }}
          path: node-bindings-${{ matrix.target }}.tar.gz
          retention-days: 14

  wasm-bindings:
    name: Build WASM bindings
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown

      - name: Install wasm-pack
        run: |
          if ! command -v wasm-pack >/dev/null 2>&1; then
            cargo install wasm-pack --locked
          fi

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          check-latest: true

      - name: Enable corepack
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --filter html-to-markdown-wasm...

      - name: Build WASM bundles
        run: pnpm --filter html-to-markdown-wasm run build:all

      - name: Package WASM artifacts
        run: |
          set -euo pipefail
          out_dir="wasm-artifacts"
          rm -rf "$out_dir"
          mkdir -p "$out_dir"
          for folder in dist dist-node dist-web; do
            if [ -d "crates/html-to-markdown-wasm/$folder" ]; then
              tar -czf "$out_dir/html-to-markdown-${folder}.tar.gz" -C crates/html-to-markdown-wasm "$folder"
            fi
          done

      - name: Upload WASM artifacts
        uses: actions/upload-artifact@v5
        with:
          name: wasm-bundles
          path: wasm-artifacts/*
          retention-days: 14

  cli-binaries:
    name: Build CLI binaries (${{ matrix.target }})
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            use_cross: false
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            use_cross: false
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            use_cross: false
          - os: macos-14
            target: aarch64-apple-darwin
            use_cross: false
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            use_cross: false
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Add compilation target
        run: rustup target add ${{ matrix.target }}

      - name: Install build dependencies
        if: runner.os == 'Linux'
        run: |
          set -euo pipefail
          sudo apt-get update
          case "${{ matrix.target }}" in
            x86_64-unknown-linux-musl)
              sudo apt-get install -y musl-tools
              ;;
            aarch64-unknown-linux-gnu)
              sudo apt-get install -y gcc-aarch64-linux-gnu
              ;;
          esac

      - name: Configure cross linker
        if: ${{ matrix.target == 'aarch64-unknown-linux-gnu' }}
        run: |
          {
            echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc"
            echo "CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++"
            echo "AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar"
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc"
          } >> "$GITHUB_ENV"

      - name: Install cross
        if: ${{ matrix.use_cross }}
        run: cargo install cross --git https://github.com/cross-rs/cross --locked

      - name: Build CLI
        shell: bash
        run: |
          set -euo pipefail
          target="${{ matrix.target }}"
          if [ "${{ matrix.use_cross }}" = "true" ]; then
            cross build --release --target "$target" --package html-to-markdown-cli
          else
            cargo build --release --target "$target" --package html-to-markdown-cli
          fi

      - name: Package CLI artifact
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          target="${{ matrix.target }}"
          stage="cli-${target}"
          rm -rf "$stage"
          mkdir -p "$stage"
          cp "target/${target}/release/html-to-markdown" "$stage/"
          cp LICENSE "$stage/"
          cp README.md "$stage/"
          tar -czf "${stage}.tar.gz" "$stage"
          rm -rf "$stage"

      - name: Package CLI artifact (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $target = '${{ matrix.target }}'
          $stage = "cli-$target"
          Remove-Item -Recurse -Force $stage -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $stage | Out-Null
          Copy-Item "target/$target/release/html-to-markdown.exe" $stage
          Copy-Item LICENSE $stage
          Copy-Item README.md $stage
          Compress-Archive -Path "$stage/*" -DestinationPath "$stage.zip" -Force
          Remove-Item -Recurse -Force $stage

      - name: Upload CLI artifact
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v5
        with:
          name: cli-${{ matrix.target }}
          path: cli-${{ matrix.target }}.tar.gz
          retention-days: 14

      - name: Upload CLI artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v5
        with:
          name: cli-${{ matrix.target }}
          path: cli-${{ matrix.target }}.zip
          retention-days: 14

  release-smoke:
    name: Smoke release artifacts (${{ matrix.os }})
    needs:
      - prepare
      - python-wheels
      - python-sdist
      - php-pie
      - node-typescript-defs
      - node-bindings
      - wasm-bindings
      - cli-binaries
      - ruby-gem
      - elixir-package
      - cargo-packages
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Download Python wheels
        uses: actions/download-artifact@v6
        with:
          name: python-wheels-${{ matrix.os }}
          path: python-wheels

      - name: Determine Ruby artifact label
        id: ruby_label
        run: |
          case "${{ matrix.os }}" in
            ubuntu-latest)
              echo "label=linux" >> "$GITHUB_OUTPUT"
              ;;
            macos-latest)
              echo "label=macos-arm64" >> "$GITHUB_OUTPUT"
              ;;
            windows-latest)
              echo "label=windows-x64" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Unsupported matrix.os=${{ matrix.os }}" >&2
              exit 1
              ;;
          esac

      - name: Download Ruby gems
        uses: actions/download-artifact@v6
        with:
          name: rubygems-${{ steps.ruby_label.outputs.label }}
          path: ruby-gems

      - name: Download Elixir package
        uses: actions/download-artifact@v6
        with:
          name: elixir-hex-package
          path: elixir-package

      - name: Inspect Elixir package
        run: |
          set -euo pipefail
          ls -l elixir-package
          tar -tf elixir-package/html_to_markdown-*.tar >/dev/null

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"

      - name: Setup Ruby
        if: runner.os != 'Windows'
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3"
          bundler-cache: false

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Setup PHP
        if: runner.os == 'Linux'
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.2"
          tools: composer:2.9.1

      - name: Capture php-config path
        if: runner.os == 'Linux'
        run: echo "PHP_CONFIG=$(command -v php-config)" >> "$GITHUB_ENV"

      - name: Smoke Python install
        uses: ./.github/actions/smoke-python

      - name: Smoke Ruby install
        if: runner.os != 'Windows'
        uses: ./.github/actions/smoke-ruby

      - name: Build PHP extension
        if: runner.os == 'Linux'
        id: build_php_smoke
        uses: ./.github/actions/build-php-linux
        with:
          php-config: ${{ env.PHP_CONFIG }}

      - name: Smoke PHP install
        if: runner.os == 'Linux'
        uses: ./.github/actions/smoke-php-linux
        with:
          extension-path: ${{ steps.build_php_smoke.outputs.extension-path }}

      - name: Smoke Rust example
        uses: ./.github/actions/smoke-rust

      - name: Smoke Go install
        uses: ./.github/actions/smoke-go

      - name: Smoke C# install
        uses: ./.github/actions/smoke-csharp

      - name: Download CLI artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: cli-*
          path: cli-artifacts
          merge-multiple: false

      - name: Download PHP PIE artifacts
        if: runner.os == 'Linux'
        uses: actions/download-artifact@v6
        with:
          name: php-pie-src
          path: php-pie-artifacts

      - name: Smoke CLI binary
        uses: ./.github/actions/smoke-cli
        with:
          cli-artifacts-dir: ${{ github.workspace }}/cli-artifacts

      - name: Smoke PIE install (Linux)
        if: runner.os == 'Linux'
        uses: ./.github/actions/smoke-pie
        with:
          pie-artifacts-dir: ${{ github.workspace }}/php-pie-artifacts

  smoke-java:
    name: Smoke Java install
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: "22"
          cache: maven

      - name: Smoke Java install
        uses: ./.github/actions/smoke-java

  ruby-gem:
    name: Build Ruby gem (${{ matrix.label }})
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            label: linux
          - os: macos-14
            label: macos-arm64
          - os: windows-latest
            label: windows-x64
    runs-on: ${{ matrix.os }}
    env:
      RB_SYS_CARGO_PROFILE: release
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Remove cached CLI binaries
        shell: bash
        run: rm -f packages/ruby/lib/bin/html-to-markdown*

      - name: Install MSYS2 toolchain
        if: runner.os == 'Windows'
        shell: pwsh
        run: ridk exec pacman -S --needed --noconfirm base-devel mingw-w64-ucrt-x86_64-toolchain

      - name: Install Rust (GNU on Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: rustup toolchain install stable-gnu --profile minimal --no-self-update

      - name: Configure bindgen sysroot (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: echo "BINDGEN_EXTRA_CLANG_ARGS=--target=x86_64-pc-windows-gnu --sysroot=${RI_DEVKIT//\\/\/}$MSYSTEM_PREFIX" >> "$GITHUB_ENV"

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3"
          bundler: "2.7.2"
          bundler-cache: false

      - name: Install Ruby dependencies (Unix)
        if: runner.os != 'Windows'
        run: bundle install --jobs 4 --retry 3
        working-directory: packages/ruby

      - name: Install Ruby dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $workspace = ridk exec bash -lc "cygpath -au '$env:GITHUB_WORKSPACE'"
          $gemdir = "$workspace/packages/ruby"
          ridk exec bash -lc "cd $gemdir && export RUSTUP_TOOLCHAIN=stable-gnu CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ && bundle install --jobs 4 --retry 3"

      - name: Build gem artifacts (Unix)
        if: runner.os != 'Windows'
        shell: bash
        working-directory: packages/ruby
        run: |
          set -euo pipefail
          bundle exec rake clean
          ruby ../../scripts/prepare_ruby_gem.rb
          bundle exec rake build

      - name: Build gem artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $workspace = ridk exec bash -lc "cygpath -au '$env:GITHUB_WORKSPACE'"
          $gemdir = "$workspace/packages/ruby"
          ridk exec bash -lc "cd $workspace && export RUSTUP_TOOLCHAIN=stable-gnu && ruby scripts/prepare_ruby_gem.rb"
          ridk exec bash -lc "cd $gemdir && export RUSTUP_TOOLCHAIN=stable-gnu CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ && bundle exec rake clean && bundle exec rake build"

      - name: Verify gem artifacts
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(packages/ruby/pkg/*.gem)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No gems were produced" >&2
            exit 1
          fi

      - name: Upload gem artifacts
        uses: actions/upload-artifact@v5
        with:
          name: rubygems-${{ matrix.label }}
          path: packages/ruby/pkg/*.gem
          retention-days: 14

  elixir-package:
    name: Build Elixir Hex package
    needs: prepare
    runs-on: ubuntu-latest
    env:
      MIX_ENV: dev
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: "1.19"
          otp-version: "28.1"

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Install Hex and Rebar
        run: |
          mix local.hex --force
          mix local.rebar --force

      - name: Install dependencies
        working-directory: packages/elixir
        run: mix deps.get

      - name: Run Elixir tests
        working-directory: packages/elixir
        env:
          MIX_ENV: test
        run: mix test

      - name: Build Hex package
        working-directory: packages/elixir
        run: mix hex.build

      - name: Upload Hex artifact
        uses: actions/upload-artifact@v5
        with:
          name: elixir-hex-package
          path: packages/elixir/html_to_markdown-*.tar
          retention-days: 14

  csharp-package:
    name: Build C# NuGet package
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "8.0.x"

      - name: Install dependencies
        working-directory: packages/csharp/HtmlToMarkdown
        run: dotnet restore

      - name: Pack NuGet package
        run: dotnet pack packages/csharp/HtmlToMarkdown/HtmlToMarkdown.csproj --configuration Release --output artifacts/csharp

      - name: Upload NuGet artifact
        uses: actions/upload-artifact@v5
        with:
          name: csharp-nuget
          path: artifacts/csharp/*.nupkg
          retention-days: 14

  cargo-packages:
    name: Package Rust crates
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Package crates
        env:
          RELEASE_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail
          cargo package -p html-to-markdown-rs --allow-dirty

          cli_packaged=0
          cli_status=0
          cargo package -p html-to-markdown-cli --allow-dirty --no-verify || cli_status=$?

          if [ "$cli_status" -eq 0 ]; then
            cli_packaged=1
          else
            echo "::warning::Skipping html-to-markdown-cli crate packaging; html-to-markdown-rs ${RELEASE_VERSION:-unknown} is not yet available on crates.io."
            if [ -n "${GITHUB_STEP_SUMMARY:-}" ]; then
              {
                echo "### html-to-markdown-cli crate"
                echo ""
                echo "- Packaging skipped because html-to-markdown-rs ${RELEASE_VERSION:-unknown} is not yet published to crates.io."
              } >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

          mkdir -p crate-artifacts
          cp target/package/html-to-markdown-rs-*.crate crate-artifacts/
          if [ "$cli_packaged" -eq 1 ]; then
            cp target/package/html-to-markdown-cli-*.crate crate-artifacts/
          fi

      - name: Upload crate packages
        uses: actions/upload-artifact@v5
        with:
          name: cargo-crates
          path: crate-artifacts/*.crate
          retention-days: 14

  upload-release-artifacts:
    name: Upload Release Artifacts
    needs: [prepare, python-wheels, python-sdist, php-pie, node-typescript-defs, node-bindings, wasm-bindings, cli-binaries, ruby-gem, elixir-package, cargo-packages, release-smoke]
    if: ${{ needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Download PHP PIE artifact
        uses: actions/download-artifact@v6
        with:
          name: php-pie-src
          path: dist/php-pie

      - name: Download CLI artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: cli-*
          path: dist/cli
          merge-multiple: false

      - name: Download Elixir package
        uses: actions/download-artifact@v6
        with:
          name: elixir-hex-package
          path: dist/elixir

      - name: Upload PHP PIE source bundle
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ needs.prepare.outputs.tag }} \
            dist/php-pie/php_html_to_markdown-${{ needs.prepare.outputs.version }}-src.tgz \
            --clobber

      - name: Upload CLI binaries
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          shopt -s nullglob
          for archive in dist/cli/*/*.{tar.gz,zip}; do
            if [ -f "$archive" ]; then
              gh release upload ${{ needs.prepare.outputs.tag }} "$archive" --clobber
            fi
          done

      - name: Upload Elixir package
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          shopt -s nullglob
          for pkg in dist/elixir/*.tar; do
            gh release upload ${{ needs.prepare.outputs.tag }} "$pkg" --clobber
          done

  publish-crates:
    name: Publish crates.io packages
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Verify Cargo.toml version matches tag
        run: |
          cargo_version=$(grep '^version = ' Cargo.toml | head -1 | sed -E 's/version = "(.*)"/\1/')
          tag_version="${{ needs.prepare.outputs.version }}"
          if [ "$cargo_version" != "$tag_version" ]; then
            echo "Version mismatch! Cargo: $cargo_version, tag: $tag_version" >&2
            exit 1
          fi
          echo "Cargo.toml version matches tag: $cargo_version"

      - name: Check crates.io for existing release
        id: crate_check
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          import sys
          import urllib.request
          version = os.environ["VERSION"]
          crates = [
              ("html-to-markdown-rs", "rs_exists"),
              ("html-to-markdown-cli", "cli_exists"),
          ]
          for crate, key in crates:
              url = f"https://crates.io/api/v1/crates/{crate}"
              try:
                  with urllib.request.urlopen(url) as resp:
                      data = json.load(resp)
              except Exception as exc:  # pragma: no cover
                  print(f"::warning::{crate}: failed to query crates.io ({exc})", file=sys.stderr)
                  exists = False
              else:
                  versions = [item.get("num") for item in data.get("versions", [])]
                  exists = version in versions
                  message = "already" if exists else "not yet"
                  print(f"::notice::{crate} {version} {message} published", file=sys.stderr)
              print(f"{key}={'true' if exists else 'false'}")
          PY

      - name: Publish html-to-markdown-rs
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: cargo publish -p html-to-markdown-rs --token ${{ secrets.CARGO_TOKEN }}

      - name: Wait for indexing
        if: ${{ steps.crate_check.outputs.rs_exists != 'true' }}
        run: sleep 30

      - name: Publish html-to-markdown-cli
        if: ${{ steps.crate_check.outputs.cli_exists != 'true' }}
        run: cargo publish -p html-to-markdown-cli --token ${{ secrets.CARGO_TOKEN }}

  publish-pypi:
    name: Publish Python packages to PyPI
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      id-token: write
    steps:
      - name: Download wheel artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: python-wheels-*
          path: dist
          merge-multiple: true

      - name: Download sdist artifact
        uses: actions/download-artifact@v6
        with:
          name: python-sdist
          path: dist

      - name: List artifacts
        run: ls -R dist

      - name: Publish to PyPI
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist
          skip-existing: true

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; artifacts staged for PyPI:" >> $GITHUB_STEP_SUMMARY
          ls -1 dist >> $GITHUB_STEP_SUMMARY

  publish-rubygems:
    name: Publish Ruby gems
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Download Ruby gem artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: rubygems-*
          path: dist
          merge-multiple: true

      - name: Configure trusted publishing credentials
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        uses: rubygems/configure-rubygems-credentials@v1.0.0

      - name: Check RubyGems version
        id: rubygems_check
        run: |
          set -euo pipefail
          export VERSION="${{ needs.prepare.outputs.version }}"
          exists=$(python3 - <<'PY'
          import json, os, urllib.request
          version = os.environ["VERSION"]
          with urllib.request.urlopen("https://rubygems.org/api/v1/versions/html-to-markdown.json") as resp:
              data = json.load(resp)
          exists = any(entry.get("number") == version for entry in data)
          print("true" if exists else "false")
          PY
          )
          echo "exists=$exists" >> "$GITHUB_OUTPUT"

      - name: Publish gems
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.rubygems_check.outputs.exists != 'true' }}
        working-directory: dist
        run: |
          set -euo pipefail
          shopt -s nullglob
          gems=($(ls html-to-markdown-*.gem | sort))
          if [ ${#gems[@]} -eq 0 ]; then
            echo "No gem artifacts found" >&2
            exit 1
          fi
          for gem in "${gems[@]}"; do
            echo "Pushing ${gem}"
            gem push "$gem"
          done

      - name: Ruby gem already published
        if: ${{ steps.rubygems_check.outputs.exists == 'true' }}
        run: echo "RubyGem version ${{ needs.prepare.outputs.version }} already published; skipping." >> $GITHUB_STEP_SUMMARY

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        working-directory: dist
        run: |
          echo "Dry run requested; gem artifacts ready:" >> $GITHUB_STEP_SUMMARY
          ls -1 html-to-markdown-*.gem >> $GITHUB_STEP_SUMMARY

  publish-hex:
    name: Publish Hex package
    needs: [prepare, elixir-package, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Setup Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: "1.19"
          otp-version: "28.1"

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Install Hex/Rebar
        run: |
          mix local.hex --force
          mix local.rebar --force

      - name: Install dependencies
        working-directory: packages/elixir
        run: mix deps.get

      - name: Check Hex version
        id: hex_check
        run: |
          set -euo pipefail
          export VERSION="${{ needs.prepare.outputs.version }}"
          exists=$(python3 - <<'PY'
          import json, os, urllib.request
          version = os.environ["VERSION"]
          with urllib.request.urlopen("https://hex.pm/api/packages/html_to_markdown") as resp:
              data = json.load(resp)
          exists = any(rel.get("version") == version for rel in data.get("releases", []))
          print("true" if exists else "false")
          PY
          )
          echo "exists=$exists" >> "$GITHUB_OUTPUT"

      - name: Publish to Hex.pm
        if: ${{ steps.hex_check.outputs.exists != 'true' }}
        run: |
          set -euo pipefail
          cd packages/elixir
          mix hex.publish --yes
        env:
          HEX_API_KEY: ${{ secrets.HEX_TOKEN }}

      - name: Hex package already published
        if: ${{ steps.hex_check.outputs.exists == 'true' }}
        run: echo "Hex package ${{ needs.prepare.outputs.version }} already published; skipping." >> $GITHUB_STEP_SUMMARY

  publish-nuget:
    name: Publish NuGet package
    needs: [prepare, csharp-package, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "8.0.x"

      - name: NuGet login (OIDC â†’ temp API key)
        id: nuget-login
        uses: NuGet/login@v1
        with:
          user: "nhirschfeld"

      - name: Download NuGet artifact
        uses: actions/download-artifact@v6
        with:
          name: csharp-nuget
          path: dist/nuget

      - name: Publish package to NuGet.org
        env:
          DOTNET_NOLOGO: true
        run: |
          set -euo pipefail
          for pkg in dist/nuget/*.nupkg; do
            dotnet nuget push "$pkg" \
              --api-key "${{ steps.nuget-login.outputs.NUGET_API_KEY }}" \
              --source https://api.nuget.org/v3/index.json \
              --skip-duplicate
          done

  publish-maven:
    name: Publish Maven package
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: "22"
          cache: maven
          server-id: central
          server-username: MAVEN_USERNAME
          server-password: MAVEN_PASSWORD
          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
          gpg-passphrase: ${{ secrets.GPP_PASSPHRASE }}

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Prefer gpg2 binary
        run: |
          set -euo pipefail
          if command -v gpg2 >/dev/null 2>&1; then
            mkdir -p "${HOME}/.local/bin"
            printf '#!/usr/bin/env bash\nexec gpg2 "$@"\n' > "${HOME}/.local/bin/gpg"
            chmod +x "${HOME}/.local/bin/gpg"
            echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
            echo "PATH=${HOME}/.local/bin:${PATH}" >> "$GITHUB_ENV"
          fi

      - name: Release Maven package
        env:
          MAVEN_USERNAME: ${{ secrets.MAVEN_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.MAVEN_PASSWORD }}
          MAVEN_GPG_PASSPHRASE: ${{ secrets.GPP_PASSPHRASE }}
          GPG: /usr/bin/gpg2
        run: |
          set -euo pipefail
          mvn -f packages/java/pom.xml --batch-mode --no-transfer-progress clean deploy

  publish-node:
    name: Publish Node packages
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Download Node artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: node-bindings-*
          path: node-artifacts
          merge-multiple: true

      - name: Download TypeScript definitions
        uses: actions/download-artifact@v6
        with:
          name: node-typescript-defs
          path: typescript-defs

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Enable corepack
        run: corepack enable

      - name: Prepare artifact directory
        run: |
          rm -rf crates/html-to-markdown-node/npm
          mkdir -p crates/html-to-markdown-node
          for pkg in node-artifacts/*.tar.gz; do
            tar -xzf "$pkg" -C crates/html-to-markdown-node
          done
          # Copy TypeScript definitions to package root
          cp typescript-defs/index.js typescript-defs/index.d.ts crates/html-to-markdown-node/

      - name: Node artifacts summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; Node binding tarballs staged:" >> $GITHUB_STEP_SUMMARY
          find node-artifacts -name '*.tar.gz' -printf '%f\n' >> $GITHUB_STEP_SUMMARY

      - name: Install workspace dependencies
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        run: pnpm install --filter html-to-markdown-node...

      - name: Pack platform packages
        run: |
          cd crates/html-to-markdown-node/npm
          for dir in */; do
            if [ -f "$dir/package.json" ]; then
              (cd "$dir" && npm pack && mv *.tgz ..)
            fi
          done

      - name: Publish native binary packages
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          for pkg in crates/html-to-markdown-node/npm/*.tgz; do
            echo "Publishing $pkg"
            publish_log=$(mktemp)
            set +e
            npm publish "$pkg" --access public --ignore-scripts 2>&1 | tee "$publish_log"
            status=${PIPESTATUS[0]}
            set -e
            if [ "$status" -ne 0 ]; then
              if grep -q "previously published versions" "$publish_log"; then
                echo "Package $pkg already published; skipping."
              else
                exit "$status"
              fi
            fi
          done

      - name: Publish main Node package
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          cd crates/html-to-markdown-node
          publish_log=$(mktemp)
          set +e
          pnpm publish --access public --no-git-checks 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -q "previously published versions" "$publish_log"; then
              echo "Node package already published; skipping."
            else
              exit "$status"
            fi
          fi

  publish-wasm:
    name: Publish WASM package
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Download WASM artifacts
        uses: actions/download-artifact@v6
        with:
          name: wasm-bundles
          path: wasm-artifacts

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Extract WASM artifacts
        run: |
          cd wasm-artifacts
          for tarball in *.tar.gz; do
            tar -xzf "$tarball" -C ../crates/html-to-markdown-wasm
          done

      - name: Publish WASM package
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          cd crates/html-to-markdown-wasm
          publish_log=$(mktemp)
          set +e
          npm publish --access public 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -q "previously published versions" "$publish_log"; then
              echo "WASM package already published; skipping."
            else
              exit "$status"
            fi
          fi

  publish-homebrew:
    name: Update Homebrew formula
    needs: [prepare, upload-release-artifacts]
    if: ${{ needs.prepare.result == 'success' && needs.prepare.outputs.tag && needs.prepare.outputs.dry_run != 'true' && needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Extract release info
        id: release
        run: |
          tag="${{ needs.prepare.outputs.tag }}"
          version="${{ needs.prepare.outputs.version }}"
          url="https://github.com/Goldziher/html-to-markdown/archive/$tag.tar.gz"

          echo "tag=$tag" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "url=$url" >> $GITHUB_OUTPUT

          echo "Release info:"
          echo "  Tag: $tag"
          echo "  Version: $version"
          echo "  URL: $url"

      - name: Update Homebrew formula
        uses: mislav/bump-homebrew-formula-action@v3
        with:
          formula-name: html-to-markdown
          formula-path: Formula/html-to-markdown.rb
          homebrew-tap: Goldziher/homebrew-tap
          tag-name: ${{ needs.prepare.outputs.tag }}
          download-url: ${{ steps.release.outputs.url }}
          commit-message: |
            chore(homebrew): update html-to-markdown to ${{ steps.release.outputs.version }}

            Auto-update from release ${{ steps.release.outputs.tag }}
        env:
          COMMITTER_TOKEN: ${{ secrets.HOMEBREW_TOKEN }}
